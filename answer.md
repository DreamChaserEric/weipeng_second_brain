#### 两数之和-输入有序数组[167]
- 遍历，依次枚举。O(n^2)
- 相向双指针

#### 三数之和[15]
- 先排序。遍历+相向双指针。遍历到的数与之前相同，直接跳过。

#### 盛最多水的容器[11]
- 相向双指针。移动短的边。

#### 接雨水[42]
- 每一格的容量 = min(向左最大, 向右最大) - 格子本身高度。用2个数组，分别存左右最大。

#### 长度最小的子数组[209]
- 暴力解法。2次循环。
- 双指针，最大可能保留上次计算结果。

#### 乘积小于k的子数组[713]
- 双指针

#### 无重复字符的最长子串[3]
- 双指针

#### 在排序数组中查找元素的第一个和最后一个位置[34]
- 二分查找

#### 寻找峰值[162]
- 二分，红蓝染色？

#### 寻找旋转排序数组中的最小值[153]
- 二分?

## 回溯
#### 电话号码的字母组合[17]

#### 子集[78]

#### 分割回文串[131]

## 链表
#### 翻转链表[206]
- a.记录next；将current->Pre；Pre = Cur; Cur =  记录的Next

#### 反转链表二[92]
- 206的变种

#### K个一组反转链表[25]
- 92的变种

#### 链表的中间节点[876]
- 快慢指针, 快每步走2，慢每步走1

#### 环形链表[141]
- 快慢指针。双指针一定会进入环，入环后变为追及问题。

#### 环形链表二。判断环且找到环的入口。[142]
- 相遇时，慢指针肯定没走完一圈环。所以相遇时，再起一个指针从头开始一起走，最终会在入口相遇。

#### 重排链表[143]
- 找到中间节点；反转后半段；合并

#### 删除链表中的节点[237]
- 下一个节点的值copy过来；删除下一个节点

#### 删除链表的倒数第N个节点[19]
- 双指针。右指针先走N步。

#### 删除链表中的重复元素[83]
- 下一个值相同，则删除，否则移动到下一个节点。

#### 删除链表中的重复元素二[82]
- 哨兵节点。比较next与next.next。


## 二叉树
#### 二叉树的最大深度[104]
- 递归；边界条件，空返回0

#### 相同的树[100]
- 递归；边界条件，都为空为ture。否则对比value.

#### 对称二叉树[101]
- 递归。对比左边的左子树与右边的右子树。

#### 平衡二叉树[110]
- 算高度然后相减。

#### 二叉树的右视图[199]
- 层序遍历，返回每层的最后一个值

#### 验证二叉搜索树[98]
- 递归。递归时传入节点及区间。

#### 二叉树的最近公共祖先[236]
- 递归。当前节点为空/p/q，返回当前节点;左右子树都找到，返回当前节点;仅在左右子树找到，在子树内继续递归;都找不到,返回空。

#### 二叉搜索树的最近公共祖先[235]
- 利用特性，加快判断速度。同236。

#### 二叉树层序遍历[102]
- 根节点加入current数组，子节点加入next数组。完成后将next变为current，循环进行，直到为空退出。

#### 二叉树锯齿形层序遍历[103]
- 与直接遍历相似，假如一个bool来判断

#### 二叉树左下角的值（最底层、最左边）[513]
- 层序遍历获取最后一层，输出第一个数