## 算法笔记

#### 选择排序
- 遍历整个数组，最少值放到arr[0], 遍历[index1 -> index[n-1]], 以此类推
- 算法复杂度
	+ 时间复杂度 O(n^2)
	+ 空间复杂度 O(1)

#### 冒泡排序
- 0到1位置上，谁大谁往右移，1-2位置上，谁大谁往右移，此时最右数字最大。然后在0 -> n-1位置上，以此类推。
- 算法复杂度
	+ 时间复杂度 O(n^2)
	+ 空间复杂度 O(1)

#### 异或运算，交换i位置和j位置的数
```
arr[i] = arr[i] ^ arr[j]
arr[j] = arr[i] ^ arr[j]
arr[i] = arr[i] ^ arr[j]
```
- 异或运算=》不同为1，相同为1
- 异或运算=》无进位相加
- 0 ^ N = N
- N ^ N = 0
- 满足交换律和结合律
	+ a ^ b = b ^ a
	+ (a ^ b) ^ c = a ^ (b ^ c)
- 同一批数疑惑的结果与顺序无关，都一样

#### 整形数组，只有一种数出现奇数次，其它所有数，都出现偶数次，求出现奇数次的数。
- 全部异或
- 时间复杂度O(n), 空间复杂度O(1)

#### 整形数组，有两种数出现奇数次，其它所有数，都出现偶数次，求2种数。
- 全部异或等到 a^b, 由于a!=b, a^b != 0
- 假设 a^b 的第n位为1， 让a^b 异或上第n位不为1的数，最终就可以得到a或者b
- a^b跟得到的a或者b，则可以得到另一个数
- 提取最右侧的1
	+ eor & (~eor + 1)

#### 插入排序
- 0->0有序；0->1有序，一直向前比较，交换；0->2有序，以此类推，不断往前插入
- 类似打牌：从右向左排，找到合适的位置就插入
- 算法复杂度
	+ 时间复杂度 O(n^2)
	+ 空间复杂度 O(1)

#### 二分法
- 在一个有序数组中，找某个数是否存在
	+ 二分查找
	+ 时间复杂度 O(logN)
- 在一个有序数组中，找到大于等于某个数最左侧的位置
- 局部最小值问题

#### 对数器
