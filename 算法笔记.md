## 算法笔记

#### 选择排序
- 遍历整个数组，最少值放到arr[0], 遍历[index1 -> index[n-1]], 以此类推
- 算法复杂度
	+ 时间复杂度 O(n^2)
	+ 空间复杂度 O(1)

#### 冒泡排序
- 0到1位置上，谁大谁往右移，1-2位置上，谁大谁往右移，此时最右数字最大。然后在0 -> n-1位置上，以此类推。
- 算法复杂度
	+ 时间复杂度 O(n^2)
	+ 空间复杂度 O(1)

#### 异或运算，交换i位置和j位置的数
```
arr[i] = arr[i] ^ arr[j]
arr[j] = arr[i] ^ arr[j]
arr[i] = arr[i] ^ arr[j]
```
- 异或运算=》不同为1，相同为0
- 异或运算=》无进位相加
- 0 ^ N = N
- N ^ N = 0
- 满足交换律和结合律
	+ a ^ b = b ^ a
	+ (a ^ b) ^ c = a ^ (b ^ c)
- 同一批数异或的结果与顺序无关，都一样

#### 整形数组，只有一种数出现奇数次，其它所有数，都出现偶数次，求出现奇数次的数。
- 全部异或
- 时间复杂度O(n), 空间复杂度O(1)

#### 整形数组，有两种数出现奇数次，其它所有数，都出现偶数次，求2种数。
- 全部异或等到 a^b, 由于a!=b, a^b != 0
- 假设 a^b 的第n位为1， 让a^b 异或上第n位不为1的数，最终就可以得到a或者b
- a^b跟得到的a或者b，则可以得到另一个数
- 提取最右侧的1
	+ eor & (~eor + 1)

#### 插入排序
- 0->0有序；0->1有序，一直向前比较，交换；0->2有序，以此类推，不断往前插入
- 类似打牌：从右向左排，找到合适的位置就插入
- 算法复杂度
	+ 时间复杂度 O(n^2)
	+ 空间复杂度 O(1)

#### 二分法
- 在一个有序数组中，找某个数是否存在
	+ 二分查找
	+ 时间复杂度 O(logN)
- 在一个有序数组中，找到大于等于某个数最左侧的位置
- 局部最小值问题

#### 对数器

#### 递归函数
- 递归过程可以理解为一棵多叉树
- 计算所有节点的过程，可以理解为遍历（后续遍历）
- 栈空间，就是整个数的高度
- Master公式
	+ T(N) = a*T(N/b)+O(N^d)
- 满足Master公式的递归，时间复杂度
	+ 若log以b为底的a, logb a < d, 时间复杂度为O(N^d)
	+ 若log以b为底的a, logb a > d, 时间复杂度为O(N ^ logb a)
	+ 若log以b为底的a, logb a == d, 时间复杂度为O(N^d * logN)

#### 归并排序（MergeSort）
- 左边排好序，右边排好序，整体merge
- merge行为：两个指针，谁小拷贝谁（外排序）
- Master公式：T(N) = 2*T(N/2)+O(N)
- 时间复杂度：O(NlogN)
- 空间复杂度：O(N)
- 比较行为被有效保留利用，所以时间复杂度更优秀

#### 小和问题
在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。

#### 逆序对问题
在一个数组中，如何左边的数比右边的数大，则这两个数构成一个逆序对，请打印所有逆序对

#### 荷兰国旗问题
- 给定一个数组arr，和一个数字num，请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。要求空间复杂度O(1), 时间复杂度O(N)
- 给定一个数组arr，和一个数字num，请把小于num的数放在数组的左边,等于num的数放在中间,大于num的数放在数组的右边。要求空间复杂度O(1), 时间复杂度O(N)

#### 快排
- 2.0版本：拿最后一个数字，使用荷兰国旗方法，反复递归。时间复杂度O(N^2)
- 3.0版本：随机取一个数组，作为区分数。时间复杂度O(N*logN)
	+ 空间复杂度O(logN)

#### 堆
- 逻辑概念上是一个完全二叉树
	+ 什么是完全二叉树
		- 满二叉树
		- 从左往右依次变满的数
- 大根堆：每一棵子树的最大值，就是头结点的值
- 小根堆：每一棵子树的最小值，就是头结点的值

#### 堆排序
- 0->N-1, 变成大根堆。然后将0位置与最后一个位置做交换，继续将0->N-2变成大根堆，依次进行。
- 时间复杂度：log(NlogN)
- 空间复杂度：O(1)

#### 比较器的使用

#### 不基于比较的排序
- 计数排序
- 基数排序
	+ 桶排序

#### 排序算法总结稳定性
| 算法 | 时间复杂度 | 空间复杂度 | 稳定性 |
| --- | --- | --- | --- |
| 选择 | O(N^2) | O(1) | NO |
| 冒泡 | O(N^2) | O(1) | YES |
| 插入 | O(N^2) | O(1) | YES |
| 归并 | O(NlogN) | O(N) | YES |
| 快排 | O(NlogN) | O(logN) | NO |
| 堆  | O(NlogN) | O(1) | NO |

#### 哈希表



#### 二叉树
- 递归序
- 先序
	- 对于每一棵树，按照头->左->右打印
- 中序
	- 左头右
- 后序
	- 左右头



